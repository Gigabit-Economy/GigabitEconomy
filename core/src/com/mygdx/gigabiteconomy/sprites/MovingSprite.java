package com.mygdx.gigabiteconomy.sprites;

import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.utils.Array;
import com.mygdx.gigabiteconomy.screens.Tile;
import com.mygdx.gigabiteconomy.screens.TileManager;
import com.badlogic.gdx.utils.Disposable;

/**
 * Class represents a sprite shown on screen, ready to be drawn with batch.draw(); in MainScreen class
 * MainScreen interfaces with this class through GameObject
 */
public abstract class MovingSprite extends Actor implements GameObject, Disposable {
    //Rectangle which holds the texture
    private Rectangle rect;

    TileManager tm;
    Tile currentTile;

    TextureAtlas ta;
    //Coordinates of sprite on screen
    private float[] coords = new float[2];
    //Array of regions in spritesheet
    private Array<TextureAtlas.AtlasRegion> regions;
    //Current image being displayed in the movement animation
    private TextureRegion current;

    boolean moving; //Can use for paused? Also useful for player (holding down keys)
    MoveDirection direction;

    private int[] dcoords = new int[2]; //Increment of each x, y if moving is true

    /**
     * Constructor used to create a new moving sprite
     *
     * @param config Config file, name of .txt file generated by TexturePacker application
     * @param x position of Tile (within tile grid) to place sprite
     * @param y position of Tile (within tile grid) to place sprite
     */
    public MovingSprite(String config, int x, int y) {
        ta = new TextureAtlas(config);
        regions = ta.getRegions();

        current = regions.get(0); //Change to more general name to fit with all sprites
                                                              //See about exceptions and error handling here

        setBounds(x, y, current.getRegionWidth(), current.getRegionHeight());

        coords[0] = x; coords[1] = y;

        //Creating rectangle to cover texture
        rect = new Rectangle(x, y, current.getRegionWidth(), current.getRegionHeight()); //What happens to rectangle when texture changes size (e.g. in an animation)?
    }

    @Override
    public int initTile(TileManager tmPass) {
        if (tm != null) return -1; //Returning error code if tm is already init
        this.tm = tmPass;
        currentTile = tm.placeObject((int)coords[0], (int)coords[1], this); //At init tile coords[x] will be filled with tile coords on grid
        coords[0] = currentTile.getTileCoords()[0]; coords[1] = currentTile.getTileCoords()[1];
        System.out.println("Initialised at " + coords[0] + " " + coords[1]);
        //Success
        return 0;
    }

    @Override
    public void draw(Batch batch, float alpha) {
        batch.draw(current, this.getActorX(), this.getActorY());
    }

    @Override
    public TextureRegion getCurrRegion() {
        return current;
    }

    @Override
    public float getActorX() {
        return coords[0];
    }

    @Override
    public float getActorY() {
        return coords[1];
    }

    @Override
    public void setActorX() {

    }

    @Override
    public void setActorY() {

    }

    @Override
    public Rectangle getRectangle() {
        return rect;
    }

    public void setDCoords(int dx, int dy) {
        dcoords[0] += dx; dcoords[1] += dy;
    }

    public void setMoving(boolean moving) {
        this.moving = moving;
        if (!moving) dcoords[0] = dcoords[1] = 0;
    }

    public boolean isMoving() {
        return moving;
    }

    private int[] movingFrom() {

        int[] ret = new int[2];
        System.out.println("Calculating with direction: " + direction);
        switch (direction) {
            case LEFT: //[x, y] = [1, 0]
                ret[0] = 1; ret[1] = 0;
                break;
            case RIGHT:
                ret[0] = -1; ret[1] = 0;
                break;
            case UP:
                ret[1] = 1; ret[0] = 0;
                break;
            case DOWN:
                ret[1] = -1; ret[0] = 0;
                break;
        }
        return ret;
    }

    /**
     * Method runs if boolean moving set to true
     * @param delta
     */
    public void move(float delta) {
        if (!isMoving()) return;


        //coords[0] += dcoords[0]; coords[1] += dcoords[1];

        //Changing current sprite
        //current = regions.get(regions.indexOf((TextureAtlas.AtlasRegion) current, true)+1);
        //Some 'code' for an 'animation'
        current = regions.get((regions.indexOf((TextureAtlas.AtlasRegion) current, true) + 1) % regions.size);

        //If moving is true, move delta*distance until at new tile
        //Calculated from position from 'current tile'
        if (isMoving()) {
            //coords[Math.abs(movingFrom()[1])] += (movingFrom()[0])*(delta*currentTile.getSideLength());
            System.out.println("New coords: " + coords[0] + " " + coords[1]);
            //Find difference between 'currentTile' coords and sprite coords
            float newTileCoords[] = currentTile.getTileCoords();
            float diff[] = { newTileCoords[0]-coords[0], newTileCoords[1]-coords[1] };

            System.out.println("Diff " + diff[0] + " " + diff[1]);
            //If diff[0] is negative, we're moving left, if diff[1] is pos
            float deltaX = (diff[0]/(Math.abs(diff[0])==0?1:Math.abs(diff[0])))*(delta*currentTile.getSideLength());
            float deltaY = (diff[1]/(Math.abs(diff[1])==0?1:Math.abs(diff[1])))*(delta*currentTile.getSideLength());
            coords[0] += deltaX;
            coords[1] += deltaY;
            System.out.println("Changed by " + deltaX + " " + deltaY);
        }
        if (currentTile.isOnTile(coords[0], coords[1]) != null) {
            setMoving(false);
            System.out.println("Arrived at tile");
        }
    }

    public enum MoveDirection {
        LEFT,
        RIGHT,
        UP,
        DOWN
    }

    /**
     * Remove the sprite's texture atlas from memory once the sprite is no longer needed.
     */
    public void dispose() {
        ta.dispose();
    }
}
